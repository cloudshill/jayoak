// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/strmangle"
	"github.com/volatiletech/sqlboiler/types"
)

// Sound is an object representing the database table.
type Sound struct {
	ID             int64              `boil:"id" json:"id" toml:"id" yaml:"id"`
	Name           null.String        `boil:"name" json:"name,omitempty" toml:"name" yaml:"name,omitempty"`
	AudioFileName  string             `boil:"audio_file_name" json:"audioFileName" toml:"audioFileName" yaml:"audioFileName"`
	AudioUUID      string             `boil:"audio_uuid" json:"audioUUID" toml:"audioUUID" yaml:"audioUUID"`
	MimeType       string             `boil:"mime_type" json:"mimeType" toml:"mimeType" yaml:"mimeType"`
	MD5File        string             `boil:"md5_file" json:"md5File" toml:"md5File" yaml:"md5File"`
	InstrumentID   null.Int64         `boil:"instrument_id" json:"instrumentID,omitempty" toml:"instrumentID" yaml:"instrumentID,omitempty"`
	Note           null.String        `boil:"note" json:"note,omitempty" toml:"note" yaml:"note,omitempty"`
	FrequenciesArr types.DecimalArray `boil:"frequencies_arr" json:"frequenciesArr,omitempty" toml:"frequenciesArr" yaml:"frequenciesArr,omitempty"`
	MaxFrequency   types.NullDecimal  `boil:"max_frequency" json:"maxFrequency,omitempty" toml:"maxFrequency" yaml:"maxFrequency,omitempty"`
	MinFrequency   types.NullDecimal  `boil:"min_frequency" json:"minFrequency,omitempty" toml:"minFrequency" yaml:"minFrequency,omitempty"`
	MaxPowerFreq   types.NullDecimal  `boil:"max_power_freq" json:"maxPowerFreq,omitempty" toml:"maxPowerFreq" yaml:"maxPowerFreq,omitempty"`
	MaxPowerValue  types.NullDecimal  `boil:"max_power_value" json:"maxPowerValue,omitempty" toml:"maxPowerValue" yaml:"maxPowerValue,omitempty"`
	OrganizationID int64              `boil:"organization_id" json:"organizationID" toml:"organizationID" yaml:"organizationID"`
	CreatorID      int64              `boil:"creator_id" json:"creatorID" toml:"creatorID" yaml:"creatorID"`
	ProcessedAt    null.Time          `boil:"processed_at" json:"processedAt,omitempty" toml:"processedAt" yaml:"processedAt,omitempty"`
	CreatedAt      null.Time          `boil:"created_at" json:"createdAt,omitempty" toml:"createdAt" yaml:"createdAt,omitempty"`
	UpdatedAt      null.Time          `boil:"updated_at" json:"updatedAt,omitempty" toml:"updatedAt" yaml:"updatedAt,omitempty"`
	R              *soundR            `boil:"-" json:"-" toml:"-" yaml:"-"`
	L              soundL             `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SoundColumns = struct {
	ID             string
	Name           string
	AudioFileName  string
	AudioUUID      string
	MimeType       string
	MD5File        string
	InstrumentID   string
	Note           string
	FrequenciesArr string
	MaxFrequency   string
	MinFrequency   string
	MaxPowerFreq   string
	MaxPowerValue  string
	OrganizationID string
	CreatorID      string
	ProcessedAt    string
	CreatedAt      string
	UpdatedAt      string
}{
	ID:             "id",
	Name:           "name",
	AudioFileName:  "audio_file_name",
	AudioUUID:      "audio_uuid",
	MimeType:       "mime_type",
	MD5File:        "md5_file",
	InstrumentID:   "instrument_id",
	Note:           "note",
	FrequenciesArr: "frequencies_arr",
	MaxFrequency:   "max_frequency",
	MinFrequency:   "min_frequency",
	MaxPowerFreq:   "max_power_freq",
	MaxPowerValue:  "max_power_value",
	OrganizationID: "organization_id",
	CreatorID:      "creator_id",
	ProcessedAt:    "processed_at",
	CreatedAt:      "created_at",
	UpdatedAt:      "updated_at",
}

// Generated where

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Int64 struct{ field string }

func (w whereHelpernull_Int64) EQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int64) NEQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Int64) LT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int64) LTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int64) GT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int64) GTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpertypes_DecimalArray struct{ field string }

func (w whereHelpertypes_DecimalArray) EQ(x types.DecimalArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_DecimalArray) NEQ(x types.DecimalArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_DecimalArray) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_DecimalArray) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}
func (w whereHelpertypes_DecimalArray) LT(x types.DecimalArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_DecimalArray) LTE(x types.DecimalArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_DecimalArray) GT(x types.DecimalArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_DecimalArray) GTE(x types.DecimalArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpertypes_NullDecimal struct{ field string }

func (w whereHelpertypes_NullDecimal) EQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_NullDecimal) NEQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_NullDecimal) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_NullDecimal) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpertypes_NullDecimal) LT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_NullDecimal) LTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_NullDecimal) GT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_NullDecimal) GTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var SoundWhere = struct {
	ID             whereHelperint64
	Name           whereHelpernull_String
	AudioFileName  whereHelperstring
	AudioUUID      whereHelperstring
	MimeType       whereHelperstring
	MD5File        whereHelperstring
	InstrumentID   whereHelpernull_Int64
	Note           whereHelpernull_String
	FrequenciesArr whereHelpertypes_DecimalArray
	MaxFrequency   whereHelpertypes_NullDecimal
	MinFrequency   whereHelpertypes_NullDecimal
	MaxPowerFreq   whereHelpertypes_NullDecimal
	MaxPowerValue  whereHelpertypes_NullDecimal
	OrganizationID whereHelperint64
	CreatorID      whereHelperint64
	ProcessedAt    whereHelpernull_Time
	CreatedAt      whereHelpernull_Time
	UpdatedAt      whereHelpernull_Time
}{
	ID:             whereHelperint64{field: `id`},
	Name:           whereHelpernull_String{field: `name`},
	AudioFileName:  whereHelperstring{field: `audio_file_name`},
	AudioUUID:      whereHelperstring{field: `audio_uuid`},
	MimeType:       whereHelperstring{field: `mime_type`},
	MD5File:        whereHelperstring{field: `md5_file`},
	InstrumentID:   whereHelpernull_Int64{field: `instrument_id`},
	Note:           whereHelpernull_String{field: `note`},
	FrequenciesArr: whereHelpertypes_DecimalArray{field: `frequencies_arr`},
	MaxFrequency:   whereHelpertypes_NullDecimal{field: `max_frequency`},
	MinFrequency:   whereHelpertypes_NullDecimal{field: `min_frequency`},
	MaxPowerFreq:   whereHelpertypes_NullDecimal{field: `max_power_freq`},
	MaxPowerValue:  whereHelpertypes_NullDecimal{field: `max_power_value`},
	OrganizationID: whereHelperint64{field: `organization_id`},
	CreatorID:      whereHelperint64{field: `creator_id`},
	ProcessedAt:    whereHelpernull_Time{field: `processed_at`},
	CreatedAt:      whereHelpernull_Time{field: `created_at`},
	UpdatedAt:      whereHelpernull_Time{field: `updated_at`},
}

// SoundRels is where relationship names are stored.
var SoundRels = struct {
	Instrument   string
	Creator      string
	Organization string
	Frequencies  string
}{
	Instrument:   "Instrument",
	Creator:      "Creator",
	Organization: "Organization",
	Frequencies:  "Frequencies",
}

// soundR is where relationships are stored.
type soundR struct {
	Instrument   *Instrument
	Creator      *User
	Organization *Organization
	Frequencies  FrequencySlice
}

// NewStruct creates a new relationship struct
func (*soundR) NewStruct() *soundR {
	return &soundR{}
}

// soundL is where Load methods for each relationship are stored.
type soundL struct{}

var (
	soundColumns               = []string{"id", "name", "audio_file_name", "audio_uuid", "mime_type", "md5_file", "instrument_id", "note", "frequencies_arr", "max_frequency", "min_frequency", "max_power_freq", "max_power_value", "organization_id", "creator_id", "processed_at", "created_at", "updated_at"}
	soundColumnsWithoutDefault = []string{"name", "audio_file_name", "audio_uuid", "mime_type", "md5_file", "instrument_id", "note", "frequencies_arr", "max_frequency", "min_frequency", "max_power_freq", "max_power_value", "organization_id", "creator_id", "processed_at", "created_at", "updated_at"}
	soundColumnsWithDefault    = []string{"id"}
	soundPrimaryKeyColumns     = []string{"id"}
)

type (
	// SoundSlice is an alias for a slice of pointers to Sound.
	// This should generally be used opposed to []Sound.
	SoundSlice []*Sound
	// SoundHook is the signature for custom Sound hook methods
	SoundHook func(context.Context, boil.ContextExecutor, *Sound) error

	soundQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	soundType                 = reflect.TypeOf(&Sound{})
	soundMapping              = queries.MakeStructMapping(soundType)
	soundPrimaryKeyMapping, _ = queries.BindMapping(soundType, soundMapping, soundPrimaryKeyColumns)
	soundInsertCacheMut       sync.RWMutex
	soundInsertCache          = make(map[string]insertCache)
	soundUpdateCacheMut       sync.RWMutex
	soundUpdateCache          = make(map[string]updateCache)
	soundUpsertCacheMut       sync.RWMutex
	soundUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var soundBeforeInsertHooks []SoundHook
var soundBeforeUpdateHooks []SoundHook
var soundBeforeDeleteHooks []SoundHook
var soundBeforeUpsertHooks []SoundHook

var soundAfterInsertHooks []SoundHook
var soundAfterSelectHooks []SoundHook
var soundAfterUpdateHooks []SoundHook
var soundAfterDeleteHooks []SoundHook
var soundAfterUpsertHooks []SoundHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Sound) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range soundBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Sound) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range soundBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Sound) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range soundBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Sound) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range soundBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Sound) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range soundAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Sound) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range soundAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Sound) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range soundAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Sound) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range soundAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Sound) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range soundAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSoundHook registers your hook function for all future operations.
func AddSoundHook(hookPoint boil.HookPoint, soundHook SoundHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		soundBeforeInsertHooks = append(soundBeforeInsertHooks, soundHook)
	case boil.BeforeUpdateHook:
		soundBeforeUpdateHooks = append(soundBeforeUpdateHooks, soundHook)
	case boil.BeforeDeleteHook:
		soundBeforeDeleteHooks = append(soundBeforeDeleteHooks, soundHook)
	case boil.BeforeUpsertHook:
		soundBeforeUpsertHooks = append(soundBeforeUpsertHooks, soundHook)
	case boil.AfterInsertHook:
		soundAfterInsertHooks = append(soundAfterInsertHooks, soundHook)
	case boil.AfterSelectHook:
		soundAfterSelectHooks = append(soundAfterSelectHooks, soundHook)
	case boil.AfterUpdateHook:
		soundAfterUpdateHooks = append(soundAfterUpdateHooks, soundHook)
	case boil.AfterDeleteHook:
		soundAfterDeleteHooks = append(soundAfterDeleteHooks, soundHook)
	case boil.AfterUpsertHook:
		soundAfterUpsertHooks = append(soundAfterUpsertHooks, soundHook)
	}
}

// One returns a single sound record from the query.
func (q soundQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Sound, error) {
	o := &Sound{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for sounds")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Sound records from the query.
func (q soundQuery) All(ctx context.Context, exec boil.ContextExecutor) (SoundSlice, error) {
	var o []*Sound

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Sound slice")
	}

	if len(soundAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Sound records in the query.
func (q soundQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count sounds rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q soundQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if sounds exists")
	}

	return count > 0, nil
}

// Instrument pointed to by the foreign key.
func (o *Sound) Instrument(mods ...qm.QueryMod) instrumentQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.InstrumentID),
	}

	queryMods = append(queryMods, mods...)

	query := Instruments(queryMods...)
	queries.SetFrom(query.Query, "\"instruments\"")

	return query
}

// Creator pointed to by the foreign key.
func (o *Sound) Creator(mods ...qm.QueryMod) userQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.CreatorID),
	}

	queryMods = append(queryMods, mods...)

	query := Users(queryMods...)
	queries.SetFrom(query.Query, "\"users\"")

	return query
}

// Organization pointed to by the foreign key.
func (o *Sound) Organization(mods ...qm.QueryMod) organizationQuery {
	queryMods := []qm.QueryMod{
		qm.Where("id=?", o.OrganizationID),
	}

	queryMods = append(queryMods, mods...)

	query := Organizations(queryMods...)
	queries.SetFrom(query.Query, "\"organizations\"")

	return query
}

// Frequencies retrieves all the frequency's Frequencies with an executor.
func (o *Sound) Frequencies(mods ...qm.QueryMod) frequencyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"frequencies\".\"sound_id\"=?", o.ID),
	)

	query := Frequencies(queryMods...)
	queries.SetFrom(query.Query, "\"frequencies\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"frequencies\".*"})
	}

	return query
}

// LoadInstrument allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (soundL) LoadInstrument(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSound interface{}, mods queries.Applicator) error {
	var slice []*Sound
	var object *Sound

	if singular {
		object = maybeSound.(*Sound)
	} else {
		slice = *maybeSound.(*[]*Sound)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &soundR{}
		}
		if !queries.IsNil(object.InstrumentID) {
			args = append(args, object.InstrumentID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &soundR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.InstrumentID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.InstrumentID) {
				args = append(args, obj.InstrumentID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`instruments`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Instrument")
	}

	var resultSlice []*Instrument
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Instrument")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for instruments")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for instruments")
	}

	if len(soundAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Instrument = foreign
		if foreign.R == nil {
			foreign.R = &instrumentR{}
		}
		foreign.R.Sounds = append(foreign.R.Sounds, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.InstrumentID, foreign.ID) {
				local.R.Instrument = foreign
				if foreign.R == nil {
					foreign.R = &instrumentR{}
				}
				foreign.R.Sounds = append(foreign.R.Sounds, local)
				break
			}
		}
	}

	return nil
}

// LoadCreator allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (soundL) LoadCreator(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSound interface{}, mods queries.Applicator) error {
	var slice []*Sound
	var object *Sound

	if singular {
		object = maybeSound.(*Sound)
	} else {
		slice = *maybeSound.(*[]*Sound)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &soundR{}
		}
		args = append(args, object.CreatorID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &soundR{}
			}

			for _, a := range args {
				if a == obj.CreatorID {
					continue Outer
				}
			}

			args = append(args, obj.CreatorID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`users`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load User")
	}

	var resultSlice []*User
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice User")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for users")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for users")
	}

	if len(soundAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Creator = foreign
		if foreign.R == nil {
			foreign.R = &userR{}
		}
		foreign.R.CreatorSounds = append(foreign.R.CreatorSounds, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CreatorID == foreign.ID {
				local.R.Creator = foreign
				if foreign.R == nil {
					foreign.R = &userR{}
				}
				foreign.R.CreatorSounds = append(foreign.R.CreatorSounds, local)
				break
			}
		}
	}

	return nil
}

// LoadOrganization allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (soundL) LoadOrganization(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSound interface{}, mods queries.Applicator) error {
	var slice []*Sound
	var object *Sound

	if singular {
		object = maybeSound.(*Sound)
	} else {
		slice = *maybeSound.(*[]*Sound)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &soundR{}
		}
		args = append(args, object.OrganizationID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &soundR{}
			}

			for _, a := range args {
				if a == obj.OrganizationID {
					continue Outer
				}
			}

			args = append(args, obj.OrganizationID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`organizations`), qm.WhereIn(`id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Organization")
	}

	var resultSlice []*Organization
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Organization")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for organizations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for organizations")
	}

	if len(soundAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Organization = foreign
		if foreign.R == nil {
			foreign.R = &organizationR{}
		}
		foreign.R.Sounds = append(foreign.R.Sounds, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.OrganizationID == foreign.ID {
				local.R.Organization = foreign
				if foreign.R == nil {
					foreign.R = &organizationR{}
				}
				foreign.R.Sounds = append(foreign.R.Sounds, local)
				break
			}
		}
	}

	return nil
}

// LoadFrequencies allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (soundL) LoadFrequencies(ctx context.Context, e boil.ContextExecutor, singular bool, maybeSound interface{}, mods queries.Applicator) error {
	var slice []*Sound
	var object *Sound

	if singular {
		object = maybeSound.(*Sound)
	} else {
		slice = *maybeSound.(*[]*Sound)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &soundR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &soundR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(qm.From(`frequencies`), qm.WhereIn(`sound_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load frequencies")
	}

	var resultSlice []*Frequency
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice frequencies")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on frequencies")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for frequencies")
	}

	if len(frequencyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Frequencies = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &frequencyR{}
			}
			foreign.R.Sound = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.SoundID {
				local.R.Frequencies = append(local.R.Frequencies, foreign)
				if foreign.R == nil {
					foreign.R = &frequencyR{}
				}
				foreign.R.Sound = local
				break
			}
		}
	}

	return nil
}

// SetInstrument of the sound to the related item.
// Sets o.R.Instrument to related.
// Adds o to related.R.Sounds.
func (o *Sound) SetInstrument(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Instrument) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"sounds\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"instrument_id"}),
		strmangle.WhereClause("\"", "\"", 2, soundPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.InstrumentID, related.ID)
	if o.R == nil {
		o.R = &soundR{
			Instrument: related,
		}
	} else {
		o.R.Instrument = related
	}

	if related.R == nil {
		related.R = &instrumentR{
			Sounds: SoundSlice{o},
		}
	} else {
		related.R.Sounds = append(related.R.Sounds, o)
	}

	return nil
}

// RemoveInstrument relationship.
// Sets o.R.Instrument to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Sound) RemoveInstrument(ctx context.Context, exec boil.ContextExecutor, related *Instrument) error {
	var err error

	queries.SetScanner(&o.InstrumentID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("instrument_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.R.Instrument = nil
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Sounds {
		if queries.Equal(o.InstrumentID, ri.InstrumentID) {
			continue
		}

		ln := len(related.R.Sounds)
		if ln > 1 && i < ln-1 {
			related.R.Sounds[i] = related.R.Sounds[ln-1]
		}
		related.R.Sounds = related.R.Sounds[:ln-1]
		break
	}
	return nil
}

// SetCreator of the sound to the related item.
// Sets o.R.Creator to related.
// Adds o to related.R.CreatorSounds.
func (o *Sound) SetCreator(ctx context.Context, exec boil.ContextExecutor, insert bool, related *User) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"sounds\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"creator_id"}),
		strmangle.WhereClause("\"", "\"", 2, soundPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CreatorID = related.ID
	if o.R == nil {
		o.R = &soundR{
			Creator: related,
		}
	} else {
		o.R.Creator = related
	}

	if related.R == nil {
		related.R = &userR{
			CreatorSounds: SoundSlice{o},
		}
	} else {
		related.R.CreatorSounds = append(related.R.CreatorSounds, o)
	}

	return nil
}

// SetOrganization of the sound to the related item.
// Sets o.R.Organization to related.
// Adds o to related.R.Sounds.
func (o *Sound) SetOrganization(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Organization) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"sounds\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"organization_id"}),
		strmangle.WhereClause("\"", "\"", 2, soundPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.OrganizationID = related.ID
	if o.R == nil {
		o.R = &soundR{
			Organization: related,
		}
	} else {
		o.R.Organization = related
	}

	if related.R == nil {
		related.R = &organizationR{
			Sounds: SoundSlice{o},
		}
	} else {
		related.R.Sounds = append(related.R.Sounds, o)
	}

	return nil
}

// AddFrequencies adds the given related objects to the existing relationships
// of the sound, optionally inserting them as new records.
// Appends related to o.R.Frequencies.
// Sets related.R.Sound appropriately.
func (o *Sound) AddFrequencies(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Frequency) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.SoundID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"frequencies\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"sound_id"}),
				strmangle.WhereClause("\"", "\"", 2, frequencyPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.SoundID = o.ID
		}
	}

	if o.R == nil {
		o.R = &soundR{
			Frequencies: related,
		}
	} else {
		o.R.Frequencies = append(o.R.Frequencies, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &frequencyR{
				Sound: o,
			}
		} else {
			rel.R.Sound = o
		}
	}
	return nil
}

// Sounds retrieves all the records using an executor.
func Sounds(mods ...qm.QueryMod) soundQuery {
	mods = append(mods, qm.From("\"sounds\""))
	return soundQuery{NewQuery(mods...)}
}

// FindSound retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSound(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*Sound, error) {
	soundObj := &Sound{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"sounds\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, soundObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from sounds")
	}

	return soundObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Sound) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sounds provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(soundColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	soundInsertCacheMut.RLock()
	cache, cached := soundInsertCache[key]
	soundInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			soundColumns,
			soundColumnsWithDefault,
			soundColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(soundType, soundMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(soundType, soundMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"sounds\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"sounds\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into sounds")
	}

	if !cached {
		soundInsertCacheMut.Lock()
		soundInsertCache[key] = cache
		soundInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Sound.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Sound) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	soundUpdateCacheMut.RLock()
	cache, cached := soundUpdateCache[key]
	soundUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			soundColumns,
			soundPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update sounds, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"sounds\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, soundPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(soundType, soundMapping, append(wl, soundPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update sounds row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for sounds")
	}

	if !cached {
		soundUpdateCacheMut.Lock()
		soundUpdateCache[key] = cache
		soundUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q soundQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for sounds")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for sounds")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SoundSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), soundPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"sounds\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, soundPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in sound slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all sound")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Sound) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no sounds provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(soundColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	soundUpsertCacheMut.RLock()
	cache, cached := soundUpsertCache[key]
	soundUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			soundColumns,
			soundColumnsWithDefault,
			soundColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			soundColumns,
			soundPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert sounds, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(soundPrimaryKeyColumns))
			copy(conflict, soundPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"sounds\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(soundType, soundMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(soundType, soundMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert sounds")
	}

	if !cached {
		soundUpsertCacheMut.Lock()
		soundUpsertCache[key] = cache
		soundUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Sound record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Sound) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Sound provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), soundPrimaryKeyMapping)
	sql := "DELETE FROM \"sounds\" WHERE \"id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from sounds")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for sounds")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q soundQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no soundQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sounds")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sounds")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SoundSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Sound slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(soundBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), soundPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"sounds\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, soundPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from sound slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for sounds")
	}

	if len(soundAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Sound) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSound(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SoundSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SoundSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), soundPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"sounds\".* FROM \"sounds\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, soundPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in SoundSlice")
	}

	*o = slice

	return nil
}

// SoundExists checks if the Sound row exists.
func SoundExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"sounds\" where \"id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, iD)
	}

	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if sounds exists")
	}

	return exists, nil
}
